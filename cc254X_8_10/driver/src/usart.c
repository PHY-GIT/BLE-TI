#include "usart.h" 

/****************************************************************************
* 名 称:相关全层变量定义
* 功 能:
****************************************************************************/
char RxBuf;
char UartState;
char RxData[SIZE]; //存储发送字符串

/****************************************************************************
* 名 称: InitUart()
* 功 能: 串口初始化函数
* 入口参数: 无
* 出口参数: 无
****************************************************************************/
void Uart0_Init(void)
{
    PERCFG = 0x00;           //外设控制寄存器 USART 0的IO位置:0为P0口位置1 
    P0SEL = 0x0c;            //P0_2,P0_3用作串口（外设功能）
    P2DIR &= ~0xC0;          //P0优先作为UART0
    
    U0CSR |= 0x80;           //设置为UART方式
    U0GCR |= 11;				       
    U0BAUD |= 216;           //波特率设为115200
    UTX0IF = 0;              //UART0 TX中断标志初始置位0
    U0CSR |= 0x40;           //允许接收 
    IEN0 |= 0x84;            //开总中断允许接收中断  

    UartState = UART0_RX;                      //串口0默认处于接收模式
    memset(RxData, 0, SIZE);
    
}

/****************************************************************************
* 名    称: UartSendString()
* 功    能: 串口发送函数
* 入口参数: Data:发送缓冲区   len:发送长度
* 出口参数: 无
****************************************************************************/
void UartSendString(char *Data, uint len)
{
    uint i;  
    for(i=0; i<len; i++)
    {
        U0DBUF = *Data++;
        while(UTX0IF == 0);
        UTX0IF = 0;
    }
    
    U0DBUF = 0x0A;                   //输出换行
    while(UTX0IF == 0);
    UTX0IF = 0;
}

/****************************************************************************
* 名    称: UART0_ISR(void) 串口中断处理函数 
* 描    述: 当串口0产生接收中断，将收到的数据保存在RxBuf中
****************************************************************************/
#pragma vector = URX0_VECTOR 
__interrupt void UART0_ISR(void) 
{ 
    URX0IF = 0;       // 清中断标志 
    RxBuf = U0DBUF;                           
}

/****************************************************************************
* 名    称: Uart()
* 功    能: 串口处理函数
* 入口参数: 无
* 出口参数: 无
****************************************************************************/
void UartDispose(void)
{
    static uint count =0;
    
    if (UartState == UART0_RX)              //接收状态 
    { 
        if(RxBuf != 0) 
        {         
    
            //LED1 =1;
            if((RxBuf != '#')&&(count < 50))//以'＃'为结束符,一次最多接收50个字符            
                RxData[count++] = RxBuf; 
            else
            {
                if(count >= 50)             //判断数据合法性，防止溢出
                {
                    count = 0;              //计数清0
                    memset(RxData, 0, SIZE);//清空接收缓冲区
                }
                else
                    UartState = UART0_TX;  //进入发送状态 
            }
            RxBuf  = 0;
        }
    }
    
    if (UartState == UART0_TX)              //发送状态 
    {     
        //LED1 =0; 
        U0CSR &= ~0x40;                    //禁止接收 
        UartSendString(RxData, count);     //发送已记录的字符串。
        U0CSR |= 0x40;                     //允许接收 
        UartState = UART0_RX;              //恢复到接收状态 
        count = 0;                         //计数清0
        memset(RxData, 0, SIZE);           //清空接收缓冲区
    } 

}


